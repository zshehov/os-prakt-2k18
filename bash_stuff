=== Някакви наблюдения за bash  ====


----Разлика между:

counter=0
echo "asd" | while read A; do
	echo "${A}"
	((counter++))
done
echo ${counter}

и

counter=0
while read A; do
	echo "${A}"
	((counter++))
done < <(echo "asd")
echo ${counter}
# a.k.a process substitution

В първия случай while се изпълнява в subshell, т.е. всяка промяна на counter си е остава в този subshell (стойността не се връща 'нагоре' към нашия процес, в който инициализирахме counter)
Това значи, че когато while приключи стойността на counter е същата, с която започнахме

Във втория случай while се изпълнява в текущия shell, т.е. промяната на counter наистина променя counter, който инициализирахме.






----read -d 

Ако искаме да зададем delimiter, по който read да върви (default е newline) се сблъскваме с проблема, че входът ни трябва да завършва на този delimiter, за да може да прочетем и последното entry:

while read -d ' ' WORD; do
	echo "word -> ${WORD}"
done < <(echo "this is random test")

Това става, защото след като сме прочели "random", цикълът завърта и read иска да прочете до следващия ' ', като зададе на WORD прочетеното. Само, че няма следващ ' ', и read стига до EOF което резултира в exit code, който не е 0
Може да решим проблема като използваме for:

for WORD in $(echo "this is random test"); do
	echo "word -> ${WORD}"
done

Тук for задава стойност на WORD като стигне до символ от IFS. Може да имитираме различен delimiter (read -d) като зададем друга стойност на IFS

IFS=:
for WORD in $(echo "this:is:random:test"); do
	echo "word -> ${WORD}"
done






----Тестове

Имаме файл 'file' със съдържание:
=========
smth smth
11122 333
=========

if [ -f file ] && grep -q "smth" file; then ... -> може да миксираме резултата от тест с exit status-ите на произволни команди

if [ -f file ] && ! grep -q "smth" file; then ... -> може да слагаме отрицание на exit status-ите на произволни команди

if [ -f file ] || grep -q "555" file && [ ! -f file ]; then echo "true"; else echo "false";fi -> дава false значи, имаме лява асоциативност и не може да разчитаме на приоритет на операциите






----Разлики между обикновен test -> [ ] и тест на bash [[  ]]

Логически операции:

[ expr -a expr ] -----> [[ expr && expr ]]
[ expr -o expr ] -----> [[ expr || expr ]]

Имаме pattern matcher =~ САМО при [[ ]]:

[[ "asd" =~ ^as ]]  -> има exit status 0 (т.е. match-нахме)







----Примерче, за да видим какво се случва с файловите дескриптори при redirection

1) Създаваме си прост скрипт, който ще рънва в background

test-script.sh
==================
#!/bin/bash

while [ 1 ]; do
	sleep 100;
done
==================

2) Пускаме го в bg -> ./test-script.sh &

3) Получаваме pid за този процес, след което: ls -l /proc/<полученото pid>/fd
// /proc е директорията, в която живеят отражения на процесите, които рънват в момента

4) В fd директорията на някой процес са описани файловите дескриптори. Когато не сме ползвали redirection за процеса виждаме,
че symlink-ът 0 (който отговаря на stdin), 1 (stdout), 2 (stderr) сочат към някакъв /dev/pts/* (тези можем да си мислим, че са имена на терминали, за повече инфо man pty; man pts)

5) Сега да си kill-нем процеса и да го стартираме така: ./test-script.sh < 'some-existing-file.txt' 2> 'some-file-no-need-to-exist' > 'again-some-file-no-need-to-exist' &
// несъществуващитие файлове за изходите ще бъдат създадени, ако съществуват ще се truncate-нат.
// напълно валидно е да пренасочим 12> 'some-file', което ще създаде файлов дескриптор с номер 12 към 'some-file'. 0, 1, 2 са запазените file descriptors за stdin, stdout, stderr, които всеки процес има

6) Този път с ls -l /proc/<върнатото pid>/fd ще видим, че 0, 1, 2 са пренасочени, както сме обявили
7) След като сте почовъркали може да си убиете процеса

8) Сега може да пробваме същия експеримент с pipe (отгоре пренасочвахме към файлове, сега пренасочваме към процес) ->   ./test-script.sh | ./test-scripts.sh
9) С ps може да видим и pid и на двата процеса и да видим какво се случва за тях в /proc/<pid>/fd. 
1 и 0 съотвено са пренасочени към някакъв pipe (комуникационен канал който ОС е създала за нас, за да може първият процес да подава съдържание на втория)




---- PROCESS SUBSTITUTION

echo "asd" > file.txt   : пренасочвахме ИЗХОДА на echo към файл file.txt
echo "asd" | cat -      : пренасочвахме ИЗХОДА на echo към ВХОДА на cat, и ВХОДА на cat да е ИЗХОДА на echo (както видяхме горе, посредством pipe предоставен ни от ОС)

 F U S I O N

echo "asd" > >(cat -)   : това се превежда до -> echo "asd" > 'някакъв файл, който е ВХОДА на командата cat -)'		-> този някакъв файл е анонимен и ОС е грижи да го затрие, когато вече не се ползва
			: т.е. пренасочваме ИЗХОДА на echo към файл 'анонимен', и ВХОДА на cat е този файл

По-кофти вариант, който имитира това действие е: създаваме файл temp.txt и казваме:        echo "asd" > temp.txt; cat - < temp.txt

Може да проверим какъв е този файл така:
ls -l >(echo "asd")
или stat >(echo "asd")



Ако използваме <(echo "asd"), има подобно поведение. Отново прави 'анонимен' файл, но този път ИЗХОДА на echo е пренасочен към този файл

т.е. когато правим това:

while read LINE; do
	echo "${LINE}"
done < <(echo "asd")


може да го имитираме с:

echo "asd" > temp.txt

while read LINE; do
	echo "${LINE}"
done < temp.txt















