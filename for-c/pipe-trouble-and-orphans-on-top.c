#include <unistd.h>
#include <err.h>
#include <sys/wait.h>
#include <stdio.h>

int main() {

   int fd[2];
   if (pipe(fd) == -1) {
      errx(42, "We tried");
   }

   // fd[0]  == краят, от който четем
   // fd[1]  == краят, в който пишем
   // може да си измислим съотвествие с stdin и stdout, за да помним индексите по-лесно

   int pid = fork();
   
   if (pid == 0) {
      // тъй като след fork наследяваме всичко си имаме и тръбата (двата отворени файлови дескриптори)
      
      // какво се случва ако не затворим края на тръбата за писане и ръннем програмата?
      //
      // close(fd[1]);
      //
      // от man 7 pipe разбираме, че когато тръбата е празна, но има някой, който държи краят за писане отворен,
      // read-ване от края за четене ще блокира, чакайки някой да пише в тръбата.
      // Това значи, че дори родителят да затвори краят за писане, но в детето той е отворен, read-ът ще блокира
      //
      // Рънвайки програмата със закоментиран close(fd[1]) в детето и без wait в родителя, родителят просто ще 
      // приключи, но знаем, че детето ще остане да си виси на read-a. 
      // T.e. създадохме си orphan процес - parent-ът умря преди child-a
      // По-лошото за този orphan процес е, че ще виси на този read завинаги
      // може да го проверим с:
      // $ ps -o pid,ppid,comm
      //   PID  PPID COMMAND
      //   581     1 main     <-- child процеса беше осиновен от init процеса (с pid 1)
      //   583  2085 ps
      //  2085  7574 bash


      int read_size = 0;
      char buffer[128];

      while( (read_size = read(fd[0], &buffer, sizeof(buffer))) > 0) {
         // ако получим нещо, което няма null терминатор %s отдолу ще ни изиграе лоша шега
         printf("Parent said: %s\n", buffer);
      }
   } else {

      close(fd[0]);
      char lastWords[] = "Just going to buy some cigarettes, son";

      write(fd[1], &lastWords, sizeof(lastWords));

      printf("Child was with pid: %d\n", pid);
      close(fd[1]);

      // ако тук сложим един
      // wait(NULL);
      // ще чакаме детето да приключи, а то от своя страна, чака да си затвори края на тръбата за писане, което никога няма да се случи
      // не е баш deadlock, но пак сме прецакани
   }

   // изводът е, че ВИНАГИ възможно най-скоро си затваряме краищата на тръбата, които няма да използваме
}
