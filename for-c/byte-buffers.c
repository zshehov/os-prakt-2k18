#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdint.h>

int main() {

   char chars[4] = {'w',       'x',       'y',       'z'};
   // в dec:        119        120        121        122
   // като битове:  0111|0111  0111|1000  0111|1001  0111|1010   (*)
   // в hex:        7    7     7    8     7    9     7    a    ->   77 78 79 7a
   
   // т.е. ако бутнем този масив в някой файл, ще получим тази поредица от битове вътре, а с xxd ще видим 77 78 79 7a
   
   int fd = open("test", O_CREAT | O_TRUNC | O_RDWR, 00700);
   // skipping the check
   write(fd, &chars, sizeof(chars) /* 4 char-a по 1 байт = 4 байта */);

   // xxd test -> 00000000: 7778 797a                                wxyz
   
   // Отворихме файла за read и write, та направо може да се върнем в началото
   
   lseek(fd, 0, SEEK_SET);

   uint32_t four_bytes_int;

   // нека директно да прочетем съдържанието на файла в един uint32_t (използваме го като буфер, в който четем)
   
   read(fd, &four_bytes_int, sizeof(four_bytes_int));

   // сега стойността на four_bytes_int е точно последователността от файла = 7778 797а или в binary = 01110111011110000111100101111010 (преписано от (*)). Thx to binary to dec converter = 2004384122
   //  7*16^7 + 7*16^6 + 7*16^5 + 8*16^4 + 7*16^3 + 9*16^2 + 7*16^1 + a*16^0   = 2004384122
   // обаче, тъй като знаем, че сме на Little endian (thx lscpu), числовите типове се интерпретират с най-НЕзначителният най-вляво (колкото на по-малък адрес - толкова по-НЕзначителен байт).
   // т.е. в горните сметки ще трябва да променим реда на степените (basically го интерпретираме човешки като числото 7a79 7877)
   //  7*16^0 + 7*16^1 + 7*16^2 + 8*16^3 + 7*16^4 + 9*16^5 + 7*16^6 + a*16^7   = 2054781047
   
   printf("int = %d\n", four_bytes_int); 
   // получаваме int = 2054781047
   

   // освен това може да прочетем същите байтове в масив от 2 uint-а с по 2 байта всеки
   uint16_t two_bytes_ints[2];
   
   lseek(fd, 0, SEEK_SET);

   read(fd, &two_bytes_ints, sizeof(two_bytes_ints) /*  2 uint16_t по 2 байта = 4 байта */);
   // сега в two_bytes_ints[0] ни се заби 7778
   //      в two_bytes_ints[1] ни се заби 797а
   
   // за да сметнем самите стойности на числата отново ще обърнем байтовете заради Little endian т.е.
   // вместо 7*16^3 + 7*16^2 + 7*16^1 + 8*16^0 ще смятаме 7*16^0 + 7*16^1 + 7*16^2 + 8*16^3 (все едно гледаме 7877) = 30839
   // вместо 7*16^3 + 9*16^2 + 7*16^1 + a*16^0 ще смятаме 7*16^0 + 9*16^1 + 7*16^2 + a*16^3 (все едно гледаме 7a79) = 31353
   
   printf("First: %d, Second:%d\n", two_bytes_ints[0], two_bytes_ints[1]);
   // получаваме First: 30839, Second:31353
   

   // Изводът е, че: във файловете си имаме поредица от байтове (някой път се случва така, че някой байт може да го интепретираме като символ от ASCII таблицата - ако стойността му е между 32 и 126).
   // read ни хваща тази поредица от байтове и я пъха в буфера, който сме подали.
   // Този буфер essentially е последователни байтове например 4, който с еднакъв успех може да е: 
   // char arr[4]          -> [77] [78] [79] [7a]
   // uint16_t twoInts[2]  -> [7778] [797a]
   // uint32_t             -> [7778 797a]
   // ^ това е за примера, в който във файла имаме 7778797a
}
